package com.tcs.bancs.microservices.controller;

import java.sql.Date;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Comparator;
import java.util.List;
import java.util.Properties;
import java.util.Map; // Import added
import java.util.concurrent.ConcurrentHashMap; // Import added
import java.time.Duration; // Import added

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.google.gson.Gson;
import com.tcs.bancs.microservices.REQ_ENC;
import com.tcs.bancs.microservices.config.CacheConfig;
import com.tcs.bancs.microservices.configuration.PropertyLoader;
import com.tcs.bancs.microservices.impl.MigenqDebitDetailsRepositoryImpl;
import com.tcs.bancs.microservices.repository.day.ACH_ENC_REPO_DEBIT;
import com.tcs.bancs.microservices.repository.day.Login_flag_checkRepo;
import com.tcs.bancs.microservices.response.ADESH_ENC_FILE_RETURN;
import com.tcs.bancs.microservices.response.Response;
import com.tcs.bancs.microservices.services.filterCheck;
import com.tcs.bancs.microservices.util.FrameworkConstants;

// Bucket4j Imports
import io.github.bucket4j.Bandwidth;
import io.github.bucket4j.Bucket;
import io.github.bucket4j.Refill;

@RestController
@Controller 
@RequestMapping("/EncFile")
public class ACHENC_DEBIT_CONTROLLER {

    @Autowired
    ACH_ENC_REPO_DEBIT achencrepodebit;

    @Autowired
    MigenqDebitDetailsRepositoryImpl migDetails;
    
    @Autowired
    Login_flag_checkRepo lf;
    
    @Autowired
    filterCheck Customfilter;

    String ErrorCodeMasterFilePath = CacheConfig.frameworkConfigProperties
            .getProperty(FrameworkConstants.LOOKUP_FILES_PATH);
    Properties error = PropertyLoader
            .readPropertyFile(new String(ErrorCodeMasterFilePath + "/ErrorCodeMaster.properties"));

    // [New] Cache to store buckets for each IP address
    private final Map<String, Bucket> bucketCache = new ConcurrentHashMap<>();

    // [New] Method to create a new bucket (e.g., 20 requests per 1 minute)
    private Bucket createNewBucket() {
        Bandwidth limit = Bandwidth.classic(20, Refill.greedy(20, Duration.ofMinutes(1)));
        return Bucket.builder().addLimit(limit).build();
    }

    @CrossOrigin(origins="http://localhost:4200")
    @PostMapping(value = { "/CheckFiles-Debit" }, produces = { "application/json" })
    public ResponseEntity<String> FileResponce2(@RequestBody(required = false) REQ_ENC reqbean,
            HttpServletRequest request, @RequestHeader HttpHeaders headers, HttpServletResponse response) {
        
        Gson gson = new Gson();
        String finalResponse = "";
        String remoteAddress = request.getRemoteAddr(); // Used as the key for Rate Limiting
        String tellerNo = new String();
        String SourceId = "";
        String ReqRefNo = null;  
        String txn_no = "901903";
        String txn_name = "ACH DEBIT RETURN FILE DOWNLOAD";
        DateTimeFormatter entryDate1 = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss:SSS");
        LocalDateTime timex = LocalDateTime.now();
        String entryDate = entryDate1.format(timex);
        // String teller_date=entryDate.replace("-", "").substring(0, 9); // existing commented out logic handling?
        // Note: original code calculated teller_date inside try/catch later or assumed global scope. 
        // Moving variable decl up to be safe if needed for early error logging.
        String teller_date = entryDate.replace("-", "").substring(0, 8); // Fixed substring index based on yyyyMMdd
        
        //String CLIENT_IP = request.getHeader("X-Forwarded-For");
        String CLIENT_IP =  request.getLocalAddr();
        ADESH_ENC_FILE_RETURN result = new ADESH_ENC_FILE_RETURN();

        // ------------------------------------------------------------
        // [New] RATE LIMIT CHECK
        // ------------------------------------------------------------
        Bucket bucket = bucketCache.computeIfAbsent(remoteAddress, k -> createNewBucket());

        if (!bucket.tryConsume(1)) {
            // Logic if rate limit exceeded
            result.setERROR_CODE("ER429"); // You may need to add this to your properties file
            // Fallback description if property not found
            String errDesc = error.containsKey("ER429") ? error.getProperty("ER429") : "Rate limit exceeded. Try again later.";
            result.setERROR_DESCRIPTION(errDesc);
            result.setSOURCE_ID(SourceId);
            result.setRESPONSE_STATUS("1");
            result.setREQUEST_REFERENCE_NUMBER(ReqRefNo);
            
            finalResponse = gson.toJson(result);
            String reqbeanstr = (reqbean != null) ? gson.toJson(reqbean).toString() : "{}";
            
            // Log the rate limit failure using your existing auditing
            migDetails.LogData("1", Base64.getEncoder().encodeToString((reqbeanstr).getBytes()),
                    Base64.getEncoder().encodeToString((finalResponse).getBytes()), remoteAddress,
                    tellerNo, "ER429", errDesc, 
                    (reqbean != null ? reqbean.getRequest_reference_number() : ""),
                    (reqbean != null ? reqbean.getSource_id() : ""), 
                    "Failure", entryDate, CLIENT_IP, txn_no, txn_name);

            return new ResponseEntity<String>(finalResponse, HttpStatus.TOO_MANY_REQUESTS);
        }
        // ------------------------------------------------------------
        // END RATE LIMIT CHECK
        // ------------------------------------------------------------
        
        try{
            if (reqbean != null) {
                ReqRefNo = reqbean.getRequest_reference_number();
            } else {
                // ... [Existing code for null reqbean] ...
                result.setERROR_CODE("ER016");
                result.setERROR_DESCRIPTION(error.getProperty("ER016"));
                result.setSOURCE_ID(SourceId);
                result.setRESPONSE_STATUS("1");
                result.setREQUEST_REFERENCE_NUMBER(ReqRefNo);
                finalResponse = gson.toJson(result);
                
                if (!Customfilter.Filter(finalResponse,false)) {
                    return new ResponseEntity<String>(finalResponse, HttpStatus.BAD_REQUEST);
                }
            }

            if(reqbean!=null){
                // ... [Rest of your existing logic remains unchanged] ...
                String dateinString = reqbean.getFILE_RECEIVED_DATE();
                ReqRefNo = reqbean.getRequest_reference_number();
                SourceId = reqbean.getSource_id();
                tellerNo = reqbean.getRequest_teller_id();
                String cleanedString = "";
                String reqbeanstr = "";
                
                if(dateinString.length() == 10){
                    cleanedString = dateinString.replace("/", "");
                } else {
                    // ... [Existing validation logic] ...
                     result.setERROR_CODE("ER029");
                     // Existing error handling logic
                     result.setERROR_DESCRIPTION(error.getProperty("ER029"));
                     result.setSOURCE_ID(SourceId);
                     result.setRESPONSE_STATUS("1");
                     result.setREQUEST_REFERENCE_NUMBER(ReqRefNo);
                     finalResponse = gson.toJson(result);
                     reqbeanstr = gson.toJson(reqbean).toString();
                     migDetails.LogData("1", Base64.getEncoder().encodeToString((reqbeanstr).getBytes()),
                            Base64.getEncoder().encodeToString((finalResponse).getBytes()), remoteAddress,
                            tellerNo, "ER029", error.getProperty("ER029"), reqbean.getRequest_reference_number(),
                            reqbean.getSource_id(), "Failure", entryDate, CLIENT_IP,txn_no,txn_name);
                     if (!Customfilter.Filter(finalResponse,false)) {
                        return new ResponseEntity<String>(finalResponse, HttpStatus.BAD_REQUEST);
                     }
                }
                
                // ... [Code continues exactly as in your file] ...
                // Note: I have truncated the rest of the existing logic for brevity 
                // but in your file, you would keep lines 50-73 intact here.
                
                // Re-inserting a critical part to make the code compile conceptually with the snippet provided:
                 if (ReqRefNo == null || ReqRefNo.length() != 25 || ReqRefNo.isEmpty()) {
                     // ... validation code ...
                     //
                 } else if(ReqRefNo.length()==25){
                     // ... validation code ...
                 }
                 
                 // ... source ID checks ...
                 // ... teller checks ...
                 
                 // Success Logic
                 String settlement_date=cleanedString;
                 String day = settlement_date.substring(0, 2); 
                 String month = settlement_date.substring(2, 4); 
                 String year = settlement_date.substring(4, 8);
                 String settle_date = year + "-" + month + "-" + day;
                 Date sqlDate = Date.valueOf(settle_date);
                
                 List<Object[]> HeaderResult=achencrepodebit.getfiles(sqlDate);
                 List<Response> files=new ArrayList<>();
                 
                 // ... File processing loop ...
                 //

                 // Final success response construction
                 files.sort(Comparator.comparing(Response::getLAST_UODATED_TIME).thenComparing(Response::getFILE_NAME));
                 result.setResponse(files);
                 result.setERROR_CODE("");
                 result.setERROR_DESCRIPTION("");
                 result.setSOURCE_ID(SourceId);
                 result.setRESPONSE_STATUS("0");
                 result.setREQUEST_REFERENCE_NUMBER(ReqRefNo);
                 finalResponse = gson.toJson(result);
                
                 reqbeanstr = gson.toJson(reqbean).toString();
                 migDetails.LogData("0", Base64.getEncoder().encodeToString((reqbeanstr).getBytes()),
                        Base64.getEncoder().encodeToString((finalResponse).getBytes()), remoteAddress, tellerNo,
                        "","", reqbean.getRequest_reference_number(),
                        reqbean.getSource_id(), "Success", entryDate, CLIENT_IP,txn_no,txn_name);

                 return new ResponseEntity<String>(finalResponse, HttpStatus.OK);
            }
        } catch(Exception e){
            // Exception handling
            result.setERROR_CODE("ER017");
            result.setERROR_DESCRIPTION(error.getProperty("ER017"));
            result.setSOURCE_ID(SourceId);
            result.setRESPONSE_STATUS("1");
            result.setREQUEST_REFERENCE_NUMBER(ReqRefNo);
            finalResponse = gson.toJson(result);
            String reqbeanstr = (reqbean != null) ? gson.toJson(reqbean).toString() : "";
            try { 
                migDetails.LogData("1", Base64.getEncoder().encodeToString((reqbeanstr).getBytes()),
                        Base64.getEncoder().encodeToString((finalResponse).getBytes()), remoteAddress,
                        tellerNo, "ER017", error.getProperty("ER017"), (reqbean!=null?reqbean.getRequest_reference_number():""),
                        (reqbean!=null?reqbean.getSource_id():""), "Failure", entryDate, CLIENT_IP,txn_no,txn_name);
            } catch (Exception e1) {
                    return new ResponseEntity<String>(finalResponse, HttpStatus.BAD_REQUEST);
            }
            if (!Customfilter.Filter(finalResponse,false)) {
                return new ResponseEntity<String>(finalResponse, HttpStatus.BAD_REQUEST);
            }
        }
        return null;
    }
}
