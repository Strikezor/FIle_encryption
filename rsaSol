package com.tcs.sbi.main;

import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Security;
import java.security.Signature;
import java.util.Base64;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.bouncycastle.bcpg.ArmoredOutputStream;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.openpgp.PGPCompressedData;
import org.bouncycastle.openpgp.PGPCompressedDataGenerator;
import org.bouncycastle.openpgp.PGPEncryptedData;
import org.bouncycastle.openpgp.PGPEncryptedDataGenerator;
import org.bouncycastle.openpgp.PGPException;
import org.bouncycastle.openpgp.PGPLiteralData;
import org.bouncycastle.openpgp.PGPPublicKey;
import org.bouncycastle.openpgp.PGPUtil;
import org.bouncycastle.openpgp.operator.jcajce.JcePGPDataEncryptorBuilder;
import org.bouncycastle.openpgp.operator.jcajce.JcePublicKeyKeyEncryptionMethodGenerator;

import com.tcs.sbi.launcher.MandateLauncher;
import com.tcs.sbi.util.MandateUtility;

public class MandateMain implements Runnable {

    int testCounter = 0;
    File zipName;
    String type;

    public MandateMain(File folderName, String type) {
        super();
        this.zipName = folderName;
        this.type = type;
    }

    private static final Logger log = LogManager.getLogger(MandateLauncher.class);

    public void run() {
        String srcPath = MandateLauncher.getToProcessPath() + File.separator + type;
        String zippedPath = MandateLauncher.getZippedPath();
        String signedPath = MandateLauncher.getSignedPath();
        String signedFilePath = "";
        String finalXmlPath = "";
        String destPath = MandateLauncher.getDestPath();
        String backUpPath = MandateLauncher.getBackUpPath();
        PrivateKey privateKey = MandateLauncher.getPrivateKey();
        PublicKey publicKey = MandateLauncher.getPublicKey();
        PGPPublicKey pgpPublicKey = MandateLauncher.getPgpPublicKey();

        try {
            boolean success = false;
            File sourceFolder = new File(srcPath);
            File[] listOfFolders = sourceFolder.listFiles(File::isDirectory);

            log.info("Total number of folders found in source folder for ACH-Mandate to be processed is : "
                    + (listOfFolders != null ? listOfFolders.length : 0));
            boolean isZipped = false;
            boolean isSigned = false;
            boolean isEncrypted = false;

            // Zipping the folder contents
            if (!isZipped) {
                String newSrcPath = zipName.getAbsolutePath();
                String zipFilePath = zippedPath + File.separator + zipName.getName() + ".zip";
                MandateUtility.zipFolder(Paths.get(newSrcPath), Paths.get(zipFilePath));
                String currDate = new java.text.SimpleDateFormat("ddMMyyyy").format(new java.util.Date());

                isZipped = true;

                // Signing the zipped file
                if (isZipped) {
                    try {
                        signedFilePath = signedPath + File.separator + zipName.getName() + ".zip";
                        byte[] zipFileBytes = Files.readAllBytes(Paths.get(zipFilePath));
                        Signature signature = Signature.getInstance("SHA256withRSA");
                        signature.initSign(privateKey);
                        signature.update(zipFileBytes);
                        byte[] digitalSignature = signature.sign();
                        String base64ZipContent = Base64.getEncoder().encodeToString(zipFileBytes);
                        String base64Signature = Base64.getEncoder().encodeToString(digitalSignature);
                        String base64Certificate = Base64.getEncoder().encodeToString(publicKey.getEncoded());
                        String xmlContent = String.format(
                                "<Envelope> \n" +
                                "  <OrgContent>%s</OrgContent>\n" +
                                "  <Signature>%s</Signature>\n" +
                                "  <Certificate>%s</Certificate>\n" +
                                "</Envelope>",
                                base64ZipContent,
                                base64Signature,
                                base64Certificate
                        );
                        finalXmlPath = signedFilePath.replaceAll("(?i)\\.zip$", ".xml");
                        Files.write(Paths.get(finalXmlPath), xmlContent.getBytes(StandardCharsets.UTF_8));
                        isSigned = true;

                        // Encrypting the file
                        if (isSigned) {
                            try {
                                Files.createDirectories(Paths.get(destPath + File.separator + currDate));
                                String encryptedFilePath = destPath + File.separator + currDate + File.separator
                                        + zipName.getName() + ".zip"; // Output file path

                                // Use try-with-resources to ensure file stream closes
                                try (OutputStream fileOut = new BufferedOutputStream(new FileOutputStream(encryptedFilePath))) {
                                    
                                    // CALLING THE NEW METHOD HERE
                                    boolean encryptionResult = rsaEncryptFile(
                                            fileOut, 
                                            finalXmlPath,   // Input File (The Signed XML)
                                            pgpPublicKey, 
                                            true,           // Armor (set to true as per your original logic usage)
                                            true            // Integrity Check
                                    );
                                    
                                    if(encryptionResult) {
                                        log.info("Successfully encrypted file: " + zipName.getName());
                                        success = true;
                                        isEncrypted = true;
                                    } else {
                                        throw new IOException("Encryption returned false");
                                    }
                                }

                                if (isEncrypted) {
                                    // source backup
                                    String backUpString = backUpPath + File.separator + File.separator + "SourceFilesBackUp"
                                            + File.separator + currDate + File.separator + type + File.separator
                                            + zipName.getName() + ".zip";
                                    Files.createDirectories(Paths.get(backUpPath + File.separator + File.separator
                                            + "SourceFilesBackUp" + File.separator + currDate + File.separator + type));
                                    MandateUtility.createBackUp(zipFilePath, backUpString);

                                    // output backup
                                    backUpString = backUpPath + File.separator + File.separator + "EncryptedFilesBackUp"
                                            + File.separator + currDate + File.separator + zipName.getName() + ".zip";
                                    Files.createDirectories(Paths.get(backUpPath + File.separator + File.separator
                                            + "EncryptedFilesBackUp" + File.separator + currDate + File.separator + type));
                                    MandateUtility.createBackUp(encryptedFilePath, backUpString);
                                }

                            } catch (Exception e) {
                                log.info("Error encrypting the files : " + e.getMessage());
                                e.printStackTrace();
                            }
                        } else {
                            log.info("Failed to encrypt the files (Signing failed/skipped)");
                        }
                    } catch (Exception e) {
                        log.info("Failed to sign the files: " + e.getMessage());
                    }
                } else {
                    log.info("Failed to sign the files (Zip failed/skipped)");
                }

                // Deleting files after processing
                try {
                    if (success) {
                        MandateUtility.deleteDirectory(Paths.get(newSrcPath));
                        Files.deleteIfExists(Paths.get(zipFilePath));
                        Files.deleteIfExists(Paths.get(finalXmlPath));
                    }
                } catch (Exception e) {
                    log.info("Error while deleting files from process Folders " + e.getMessage());
                }
            } else {
                log.info("Failed to zip the files");
            }
        } catch (Exception e) {
            log.error("General Exception in Run: " + e.getMessage());
        }
    }

    /**
     * Encrypts the file using PGP Encryption (RSA/AES-256)
     */
    public static boolean rsaEncryptFile(OutputStream out, String fileName,
                                         PGPPublicKey encKey, boolean armor,
                                         boolean withIntegrityCheck) throws IOException {

        boolean encrypted = false;

        Security.addProvider(new BouncyCastleProvider());

        ArmoredOutputStream armoredOut = null;
        if (armor) {
            armoredOut = new ArmoredOutputStream(out);
            out = armoredOut;
        }

        PGPCompressedDataGenerator comData = new PGPCompressedDataGenerator(PGPCompressedData.ZIP);

        ByteArrayOutputStream bOut = new ByteArrayOutputStream();

        OutputStream compressedOut = comData.open(bOut);  // MUST be closed!

        PGPUtil.writeFileToLiteralData(compressedOut, PGPLiteralData.BINARY, new File(fileName));
        compressedOut.close();   // ‚ùó REQUIRED: finalizes ZIP structure

        JcePGPDataEncryptorBuilder encryptor =
                new JcePGPDataEncryptorBuilder(PGPEncryptedData.AES_256)
                        .setWithIntegrityPacket(withIntegrityCheck)
                        .setSecureRandom(new SecureRandom())
                        .setProvider("BC");

        PGPEncryptedDataGenerator encGen = new PGPEncryptedDataGenerator(encryptor);

        encGen.addMethod(new JcePublicKeyKeyEncryptionMethodGenerator(encKey)
                .setProvider("BC")
                .setSecureRandom(new SecureRandom()));

        byte[] bytes = bOut.toByteArray();

        OutputStream encryptedOut = null;
        try {
            encryptedOut = encGen.open(out, bytes.length);
        } catch (IOException e) {
            log.info("Exception in encryption (IO): " + e.getMessage());
            encrypted = false;
            return encrypted;
        } catch (PGPException e) {
            log.info("Exception in encryption (PGP): " + e.getMessage());
            encrypted = false;
            return encrypted;
        }
        
        encryptedOut.write(bytes);
        encryptedOut.close(); // close encrypted block

        if (armor) {
            armoredOut.close(); // finalize ascii armor
        }
        
        // Note: The caller is responsible for closing the underlying 'out' stream
        // However, based on the snippet provided, it closes 'out' here. 
        // Since we passed a BufferedOutputStream from 'run', closing it here is fine.
        out.close(); 

        comData.close(); // safe to close AFTER compressedOut closed

        encrypted = true;
        return encrypted;
    }
}
